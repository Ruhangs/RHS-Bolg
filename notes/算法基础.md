---
title: '算法基础'
author: 'John Doe'
group: '算法'
date: '2022-01-01'
---

# 算法笔记（Basic）

## 第一天

### 1、异或运算

> 0^N == N  N^N == 0
> 异或运算满足交换律和结合率

不用额外变量交换两个数时可以使用，但**切记两个数所在的内存空间不一致，否则会将两个数都置为0**，例如：

```java
public viod swap(int a, int b){
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
}
```

可解决数组中的奇偶关系，从里面拿出奇数的值。eg：甲^乙^甲=乙；
甲^甲=0。

#### 两道面试题

（1）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
（2）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数（Tips:取右边第一个1，例：rightOne = a & (!a + 1)）

```txt
答：
```

### 2、对数器

它的作用一般是拿来确认自己的代码是否有错误，在没有oj的情况下，自己生成出一些测试数据。

### 3、选择排序和冒泡排序

#### （1）选择排序

排序流程：第一轮 从0到N-1选择一个大或者小的放到第一个位置，即将一个元素与后面的元素依次进行比较，第二轮 从1到N-1同理选择。

时间复杂度为O（N^2）空间复杂度 O（1）

#### （2）冒泡排序

排序流程：第一轮 依次比较相邻两个元素的大小，若左边大于右边，则交换位置，到最后一定会有一个最大的元素在数组最后（反之亦然）。如图所示：

<img src="\images\20210611113132421.gif"/>

时间复杂度为O（N^2）空间复杂度 O（1）

### 4、插入排序

排序流程：首先，第一个元素本身不存在排序问题，然后看前两个数，若前两个数，左边大于右边，则进行交换，此时前两个数有序了，在将第三个元素与第二个元素进行比较，若左大于右，交换位置，再与第一个元素进行比较，若左大于右，交换。此时，前面已没有元素了，停止，看第四个元素，往前看，同理排序。

时间复杂度：最坏O（N^2），最好O（N） 空间复杂度O（1）

### 5、二分法拓展

二分法不仅仅只针对有序数组进行查找某一个固定的元素，还可以

- 在一个有序数组中，找某个数是否存在
- 在一个有序数组中，找>=某个数最左侧的位置
- 局部最小值问题

求中间位置，一般采用：`mid = L + ((R - L) >> 1)` ，这样写不会造成溢出的问题

### 6.递归时间复杂度计算

master公式(用于求解子问题是相同规模的递归时间复杂度)：
$$
T(n) = a*T(N/b)+O(N^d)
$$

- `当logb^a < d时，复杂度为O(N^d);`
- `当logb^a > d时，复杂度为O(N^logb^a);`
- `当logb^a==d时，复杂度为O(N^d*logN);`

## 第二天

### 7、归并排序（含有递归思想）

排序流程：首先，将数组分成左右两边，然后将两边分别又进行排序（此处用到了递归思想），将已排好序的进行合并，合并的过程是两个索引分别指向左右两边的第一个元素，进行比较，将较小的元素拷贝到新数组中，且索引向右移动，直到某一边越界，将另外一边剩下的直接拷贝到新数组中。

时间复杂度：最坏O（N*lgN） 空间复杂度O（N）

**扩展：**（必出）****

![image-20220907205307534](/images/image-20220907205307534.png)

（1）求小和问题，主要思想在于将归并排序中的合并过程，左边比右边小的时候，将左边的元素×右边剩下元素的个数。最细节的地方就是，左右两边相等时，将右边放入新数组，索引向右移，才能算出此元素小于右边元素的个数。

（2）和小和问题同理

### 8、快速排序

排序流程：选取一个数（建议是随机选取，这样选取的时间复杂度为O(NlogN)）,将数组中从头i=0开始的其他元素与这个数进行比较，比它小的元素，不进行交换，将<区向右扩大一位，i++；比它大的数，i++，若再遇到比它小的数，将<区右侧的数进行交换，如何右扩一位，i++。

高阶版：

> 1）[i]<num，[i]和<区下一个交换，<区右扩，i++
>
> 2）[i]==num，i++
>
> 3）[i]<num，[i]和>区前一个交换，>区左扩，i不动

空间复杂度：o(logN)

实际问题：荷兰国旗问题

### 9、堆排序

前置知识：完全二叉树，给定一个数组，将这个数组按照完全二叉树排列，那么一个节点为数组中i位置上的数，它的父节点则为（i-1）/2上的数，左孩子为2×i + 1上的数，右孩子为2×i+2上的数。

由此在创建大根堆或者小根堆的时候，每得到一个数，都要与其根节点进行比较，若大于或者小于，则进行交换。交换之后再进行比较。

**核心思想：看节点的大小**（大根堆为例）

1）若节点的数值变了，变小了，就与它的左孩子和右孩子中最大的一个进行比较，依次循环下去，直到越界或者自己是大的

2）若节点的数值变大了，就与父节点进行比较，依次循环下去，直到越界或者自己是小的

时间复杂度：O(logN)  O(N) 空间复杂度：O（1）

![image-20220908225739120](/images/image-20220908225739120.png)

## 第三天

### 10、比较器

一般在对数据进行比较的时候，根据规则设置一个比较器。

比如说：当要将一个数组从小到大排列，此时写一个比较器，里面的返回值是两个数据作减法。

> 如果返回负数，认为第一个参数排在前面
>
> 如果返回正数，认为第二个参数排在前面
>
> 如果返回0，谁在前面都无所谓

应用场景(特殊标准的排序)：当数据比较复杂的时候，例如一个班级的学生进行排序，先按年龄排，再按成绩排序，那么一定有年龄相同的，此时就需要额外定义成绩的高低进行排序。

### 11、桶排序(基数排序)

排序流程：分别对数字的数位进行排序，先从低位开始，从0-9分别对号入座放入桶里面，然后从0-9依次从桶里面取出，先进先出的规则，个位排完之后再排十位，依次循环往复，到最高位排完结束。

## 第四天

### 12、链表结构

单链表结构

```java
Class Node<V>{
	V vlaue;
    Node next;
}
```

双链表结构

```java
Class Node<V>{
    V vlaue;
    Node next;
    Node last;
}
```

### 13、反转链表

如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

1）单链表

迭代法：

```java
public static Node reverseList(Node head) {
		Node pre = null;
		Node cur = null;
		while (head != null) {
//			1、标记当前节点的下一节点
			cur = head.next;
//			2、将当前节点，与后面的节点断开，连接到前面一个节点
			head.next = pre;
//			3、给已断开的节点做标记
			pre = head;
//			4、头指针向下移动一个
			head = cur;
		}
		return pre;
	}
```

递归法：

```java
public ListNode reverseList(ListNode head) {
    // 1. 递归终止条件
    if (head == null || head.next == null) {
        return head;
    }
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

## 第五天

### 14、两个单链表相交的一系列的问题

#### （1）对于一个单链表是否有环

①额外空间，设置一个hashset，遍历节点，若无环则一定能遍历到结尾，且不会出现重复的节点；若有环，则第一次重复出现的节点为入环节点。

②利用快慢指针，慢指针一次走一个节点，快指针一次走两个节点。当快慢指针相遇，则证明有环（慢指针进环之后绝对不会超过两圈），相遇之后，快指针回到起点（链表头），两个指针步长都为1，再次相遇时的节点为入环节点。

#### （2）对于两个单链表且无环（loop == null）的是否相交，

先判断两个链表是否相交，首先遍历两个链表到最后一个节点，并且记录最后一个节点以及链表长度，比较两个节点的内存地址是否一样，一样的则证明两条链表相交。若相交，则让长链表的指针先走两个链表之间的差值步，随后短链表跟着一起走，最后第一次相同的节点为相交节点。

#### （3）两个链表一个有环一个无环，不可能相交

#### （4）两个链表都有环，三种情况

Ⅰ、两个有环链表不相交

Ⅱ、两个有环链表相交，入环节点为一个。（流程与无环链表一致）

Ⅲ、两个有环链表相交，入环节点不相同。（选取一个链表进行遍历，遍历到loop节点结束，在遍历过程中，根据是否遇到另外一条链表的loop节点做判断，遇到了则相交，返回任意一个loop节点为交点，若没有遇到，则不相交）

### 15、二叉树遍历：递归和非递归

递归核心代码：

```java
public static void f(Node head){
    if(head == null) {
        return;
    }
    System.out.print(head.value); // 先序遍历 头左右
    f(head.left);
    System.out.print(head.value); // 中序遍历 左头右
    f(head.right);
    System.out.print(head.value); // 后序遍历 左右头
}
```

非递归，即自己压栈：

①先序：

> 1. 从栈中弹出一个节点cur
> 2. 打印（处理）cur
> 3. 先右再左（如果有的话）
> 4. 循环

①中序：

> 1. 对于每一棵子树，把左边界全压入栈，直到最后一个左边界
> 2. 弹出一个节点，打印，再向右移动一个
> 3. 继续找左边界，并压栈
> 4. 循环

②后序（定义两个栈）

> 1. 从栈中弹出一个节点cur
> 2. cur放入收集栈
> 3. 先左再右
> 4. 循环
> 5. 一次性弹出收集栈中的数据

### 16、如何完成二叉树的宽度优先遍历（常见题目：求一颗二叉树的宽度）

层序遍历用队列：LinkedList<Node> queue = new LinkedList<>();

针对题目的解法：

> 第一种方法：定义一个hashmap，存储节点以及当前节点的层数
>
> 第二种方法：标记当前层的最后一个节点以及下一层最后的一个节点

## 第六天

### 17、***（1）如何判断一颗二叉树是否是搜索二叉树?（2）如何判断一颗二叉树是完全二叉树?（3）如何判断一颗二叉树是否是满二叉树?（4）如何判断一颗二叉树是否是平衡二叉树? (二叉树题目套路)

解法：

```txt
（1）进行中序遍历，若是有序的则是搜索二叉树。因为搜索二叉树的左孩子小于根，右孩子大于根。
（2）进行层序遍历，①任意节点，有右孩子无左孩子，返回false；②在①不违规的情况下，如果遇到了第一个左右孩子不双全，那么接下来的节点全为叶节点 
（3）利用递归套路，向左（右）子树收集节点个数，以及树的高度，然后进行判断节点个数是否等于2的h次方-1
（4）判断左（右）子树是否为平衡二叉树，并且得到其深度（递归）
```

统一套路：利用递归思想，把大问题拆分为相同的小问题。**（一般解决树形dp）**

```java
// 伪代码
// 建立一个收集信息的类
public static class Info(...){
    // 属性
    // 方法
}
// 递归方法
public static info f(Node x){
    // basecase
    if(x == null){
        return ....
    }
    
    // 执行递归套路
    Info data1 = f(x.left);
    Info data2 = f(x.right);
    
    // 定义收集信息的变量，x，y等等
    // ...
    
    // 返回收集的信息
    return Info(...)
}
```

例如：第一题，首先判断左（右）子树是否为搜索二叉树，唯一不同的点是左边需要最大值，右边需要最大值，因此，在返回值的时候需要返回三个值isBst、min、max。

### 18、给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点

算法流程：

```markdown
1、首先遍历整个树，无论采用哪种遍历，在遍历过程中，将每个节点的父节点用hashmap结构存储起来
2、然后声明一个set集合，把node1往上一条线的节点放入set集合中
3、最后，查找node2往上的节点中是否存在set中储存的节点，若有返回第一次遇到的节点。
```

精简代码：

```java
public static Node lowestAncestor(Node head, Node o1, Node o2) {
		if (head == null || head == o1 || head == o2) {
			return head;
		}
		Node left = lowestAncestor(head.left, o1, o2);
		Node right = lowestAncestor(head.right, o1, o2);
		if (left != null && right != null) {
			return head;
		}
		return left != null ? left : right;
	}
```

### 19、找二叉树某节点的后继节点

一般做法，采用中序遍历，对应节点的下一个就是后继节点

利用结构特征进行优化：

①若该节点有右子树，则一直寻找到该子树的最左节点

②若该节点没有右子树，则网上寻找节点中是它父节点的左孩子，返回它的父亲（特殊情况就是整棵树的最右节点）

```java
public static Node getSuccessorNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right);
		} else {
			Node parent = node.parent;
			while (parent != null && parent.left != node) {
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

	public static Node getLeftMost(Node node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}
```

### 20、二叉树的序列化和反序列化

### 21、给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。

```java
public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true);
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false);
	}

	public static void main(String[] args) {
```

## 第七天

### 22、图的宽度优先遍历&深度优先遍历

宽度优先遍历：定义一个队列，将节点放到队列中去，然后在每次弹出节点时，处理弹出的节点，并把该节点的nexts集合中的节点，依次入队。循环往复

深度优先遍历：定义一个栈，将节点入栈，入栈时处理节点，然后判断栈是否为空，不为空，弹出节点，找到它的nexts集合中的一个节点，并且不在set集合中，然后将当前节点和下一个节点入栈，跳出nexts的循环（意思是每次只压入一个节点）。循环往复。

 ### 23、拓扑排序算法

核心思想：将每一个入度为零的点入队，然后在队为非空的情况下，弹出节点，弹出节点时，找出与它关联的点集，并且将这些点入度减一，再判断是否存在入度为零的节点。**整个过程中点的入度用hashmap记录**

### 24、kruskal算法&prim算法&dijkstra算法

kruskal算法的核心思想：将边进行排序，然后将边依次放入图中，判断是否成环，成环就不放入。具体如何判断，首先将每个节点的作为它自己的集合，若加入了一条边，两个节点的集合不相等，则不成环，成功加入，将该边的两个节点的集合融为一个集合。若相等，成环，该条边跳过。

prim算法的核心思想：随意取一个点，将该点放进该set中，代表已经查过该点了，然后将该点的所有边放入小根堆（即优先队列），弹出最小的那条边以及to节点，并判断to节点是否为新的节点。是就放入set中，将边放入节点中，不是则跳过这条边。

dijkstra算法的核心思想：维护最短路径

## 第八天

### 25、前缀树（重要）

前缀数主要维护两个变量，一个变量为pass（指经过的次数），end（到它结束的次数）。因此该前缀树可用来解决类似字符串数组中，是否存在给出的字符串，若end为0，则不存在；若end不为零，则存在，返回end值。还有是否存在给出的字符串作为前缀的有哪些字符串，用pass值来判断。返回对应的值。

### 26、贪心算法

![image-20221018160904220](/images/image-20221018160904220.png)

 堆代码中采用的是优先队列。

### 27、N皇后

## 第九天

### 28、暴力递归

试法